<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tiny Guardians: Ultimate Edition</title>
    <style>
        body { margin: 0; background-color: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Pretendard', sans-serif; overflow: hidden; user-select: none; }
        #game-container { position: relative; width: 100%; max-width: 500px; height: 100%; background-color: #2c3e50; overflow: hidden; box-shadow: 0 0 30px rgba(0,0,0,0.7); }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .top-hud { padding: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); display: flex; justify-content: space-between; align-items: center; }
        .gold-text { color: #ffd700; font-size: 18px; font-weight: bold; }

        /* ìŠ¤í‚¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .skill-container { position: absolute; right: 10px; top: 80px; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
        .skill-btn { width: 50px; height: 50px; border-radius: 12px; border: 2px solid #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: 0.2s; position: relative; }
        .skill-btn span { position: absolute; bottom: -15px; font-size: 10px; font-weight: bold; width: 100%; text-align: center; }
        .skill-btn.blizzard { background: #00bfff; }
        .skill-btn.meteor { background: #e84118; }
        .skill-btn:active { transform: scale(0.9); }
        .skill-btn.disabled { opacity: 0.3; filter: grayscale(100%); pointer-events: none; }

        .bottom-hud { padding: 10px 5px; background: rgba(0,0,0,0.9); pointer-events: auto; border-top: 1px solid #555; }
        .mana-bar-bg { width: 100%; height: 10px; background-color: #444; border-radius: 5px; margin-bottom: 8px; border: 1px solid #666; overflow: hidden; }
        .mana-bar-fill { height: 100%; background-color: #00bfff; width: 0%; transition: width 0.1s linear; }
        
        .card-container { display: flex; justify-content: space-between; gap: 4px; }
        .card-wrapper { width: 19%; position: relative; display: flex; flex-direction: column; align-items: center; }
        .upgrade-btn { width: 100%; background: #333; border: 1px solid #ffd700; color: #ffd700; font-size: 9px; padding: 4px 0; margin-bottom: 3px; border-radius: 4px; cursor: pointer; text-align: center; font-weight: bold; }
        .upgrade-btn.no-gold { border-color: #555; color: #555; pointer-events: none; }

        .card { position: relative; width: 100%; height: 65px; background: #444; border: 2px solid #666; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: 0.1s; }
        .card.active { border-color: #fff; background: #555; box-shadow: 0 0 10px rgba(255,255,255,0.5); transform: translateY(-3px); }
        .card.disabled { opacity: 0.4; pointer-events: none; filter: grayscale(100%); }
        .card-cost { position: absolute; top: -5px; left: -5px; background: #00bfff; color: white; width: 18px; height: 18px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px; border: 2px solid #fff; }
        .card-lvl { position: absolute; bottom: 2px; right: 3px; font-size: 9px; color: #ffd700; font-weight: bold; }
        .card-icon { width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; }

        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; z-index: 100; }
        .retry-btn { padding: 15px 40px; background-color: #ff4757; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 20px; font-size: 20px; font-weight: bold; }

        /* ë± ì„ íƒ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #deck-selection { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; z-index: 200; }
        .deck-selection-title { font-size: 28px; font-weight: bold; margin-bottom: 30px; color: #ffd700; }
        .deck-list { display: flex; flex-direction: column; gap: 15px; width: 90%; max-width: 400px; }
        .deck-item { background: #2c3e50; border: 2px solid #555; border-radius: 12px; padding: 20px; cursor: pointer; transition: 0.2s; }
        .deck-item:hover { border-color: #ffd700; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(255,215,0,0.3); }
        .deck-item.selected { border-color: #ffd700; background: #34495e; }
        .deck-name { font-size: 20px; font-weight: bold; margin-bottom: 10px; color: #fff; }
        .deck-cards { display: flex; gap: 8px; flex-wrap: wrap; }
        .deck-card-preview { width: 50px; height: 65px; background: #444; border: 2px solid #666; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; position: relative; }
        .deck-card-preview.unit { border-color: #00d2d3; }
        .deck-card-preview.spell { border-color: #e84118; }
        .start-btn { margin-top: 30px; padding: 15px 50px; background-color: #2ed573; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 20px; font-weight: bold; }
        .start-btn:disabled { background-color: #555; cursor: not-allowed; opacity: 0.5; }

        /* íŒ¨ ì¹´ë“œ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ */
        .card-wrapper { width: 32%; position: relative; display: flex; flex-direction: column; align-items: center; }
        .card.spell-card { border-color: #e84118; }
        .card.spell-card.active { border-color: #fff; box-shadow: 0 0 15px rgba(232,65,24,0.7); }
        .spell-indicator { position: absolute; top: 5px; right: 5px; font-size: 10px; color: #e84118; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="top-hud">
            <div>WAVE <span id="wave-num">1</span> <span id="boss-alert" style="color:#ff4757; display:none; margin-left:10px;">BOSS!</span></div>
            <div class="gold-text">ğŸª™ <span id="gold">120</span></div>
        </div>

        
        <div class="bottom-hud">
            <div style="text-align:center; font-size:12px; color:#00bfff; font-weight:bold; margin-bottom:4px;">âš¡ MANA <span id="mana-text">6</span> / <span id="mana-max">10</span></div>
            <div class="mana-bar-bg"><div id="mana-bar-fill" class="mana-bar-fill"></div></div>
            <div class="card-container" id="card-list"></div>
        </div>
    </div>

    <div id="deck-selection">
        <div class="deck-selection-title">ë± ì„ íƒ</div>
        <div class="deck-list" id="deck-list"></div>
        <button class="start-btn" id="start-btn" onclick="startGame()" disabled>ê²Œì„ ì‹œì‘</button>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>ìµœì¢… ì›¨ì´ë¸Œ: <span id="final-wave">0</span></p>
        <p>Score: <span id="final-score">0</span></p>
        <button class="retry-btn" onclick="backToMenu()">ë©”ë‰´ë¡œ</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    
    let width, height, master, units = [], enemies = [], projectiles = [], particles = [];
    let frame = 0, score = 0, gold = 120, wave = 1, mana = 6, maxMana = 10, shake = 0, isGameOver = false, selectedCard = null;
    let gameState = 'menu'; // 'menu' or 'game'
    let currentDeck = [];
    let deck = []; // ë‚¨ì€ ë± ì¹´ë“œë“¤
    let hand = []; // í˜„ì¬ íŒ¨ (ìµœëŒ€ 3ì¥)
    let deckIndex = 0; // ë±ì—ì„œ ë½‘ì„ ìœ„ì¹˜
    let selectedSpell = null; // ì„ íƒëœ ì£¼ë¬¸ ì¹´ë“œ
    let lastUsedCard = null; // ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©í•œ ì¹´ë“œ
    let bossesDefeated = 0; // ì²˜ì¹˜í•œ ë³´ìŠ¤ ìˆ˜
    let enemySpawnTimer = 0; // ì  ìŠ¤í° íƒ€ì´ë¨¸
    let bossSpawnedThisWave = false; // ì´ë²ˆ ì›¨ì´ë¸Œì— ë³´ìŠ¤ê°€ ìŠ¤í°ë˜ì—ˆëŠ”ì§€

    const UNIT_TYPES = {
        knight: { name: 'ê°€ë””ì–¸', cost: 3, count: 3, baseHp: 80, baseDmg: 15, range: 25, speed: 0.7, color: '#00d2d3', radius: 8, upgCost: 50, level: 1 },
        golem: { name: 'ê³¨ë ˜', cost: 5, count: 1, baseHp: 250, baseDmg: 8, range: 20, speed: 0.35, color: '#636e72', radius: 14, upgCost: 90, level: 1 },
        archer: { name: 'ë ˆì¸ì €', cost: 4, count: 2, baseHp: 40, baseDmg: 12, range: 120, speed: 0.6, color: '#feca57', radius: 7, upgCost: 60, level: 1 },
        bomber: { name: 'í­íƒ„ë³‘', cost: 6, count: 1, baseHp: 50, baseDmg: 35, range: 100, speed: 0.5, color: '#e17055', radius: 8, upgCost: 100, level: 1, exRadius: 45 },
        mage: { name: 'ì•„ì´ìŠ¤', cost: 5, count: 1, baseHp: 50, baseDmg: 10, range: 90, speed: 0.5, color: '#5f27cd', radius: 9, upgCost: 80, level: 1 }
    };

    const SPELL_TYPES = {
        blizzard: { name: 'ë¸”ë¦¬ìë“œ', cost: 8, icon: 'â„ï¸', color: '#00bfff' },
        meteor: { name: 'ë©”í…Œì˜¤', cost: 10, icon: 'ğŸ”¥', color: '#e84118' }
    };

    // ë¯¸ë¦¬ ì •ì˜ëœ ë±ë“¤
    const DECKS = {
        balanced: {
            name: 'ê· í˜• ë±',
            cards: [
                {type: 'unit', key: 'knight'},
                {type: 'unit', key: 'archer'},
                {type: 'spell', key: 'blizzard'},
                {type: 'unit', key: 'golem'},
                {type: 'spell', key: 'meteor'},
                {type: 'unit', key: 'mage'}
            ]
        },
        aggressive: {
            name: 'ê³µê²© ë±',
            cards: [
                {type: 'unit', key: 'knight'},
                {type: 'unit', key: 'knight'},
                {type: 'unit', key: 'bomber'},
                {type: 'spell', key: 'meteor'},
                {type: 'unit', key: 'archer'},
                {type: 'unit', key: 'archer'}
            ]
        },
        defensive: {
            name: 'ë°©ì–´ ë±',
            cards: [
                {type: 'unit', key: 'golem'},
                {type: 'unit', key: 'golem'},
                {type: 'spell', key: 'blizzard'},
                {type: 'spell', key: 'blizzard'},
                {type: 'unit', key: 'mage'},
                {type: 'unit', key: 'knight'}
            ]
        }
    };

    class Master {
        constructor() { this.x = width/2; this.y = height/2; this.radius = 40; this.hp = 150; this.maxHp = 150; }
        draw() {
            ctx.beginPath(); ctx.arc(this.x, this.y, 160, 0, Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fillStyle='#4834d4'; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.stroke();
            ctx.fillStyle='#333'; ctx.fillRect(this.x-30, this.y+50, 60, 6); ctx.fillStyle='#2ed573'; ctx.fillRect(this.x-30, this.y+50, 60*(this.hp/this.maxHp), 6);
        }
    }

    class Unit {
        constructor(x, y, typeKey) {
            const d = UNIT_TYPES[typeKey]; const mult = 1 + (d.level-1)*0.25;
            Object.assign(this, { x, y, type: typeKey, hp: d.baseHp*mult, maxHp: d.baseHp*mult, damage: d.baseDmg*mult, range: d.range, speed: d.speed, color: d.color, radius: d.radius, cooldown: 0 });
            this.maxCooldown = typeKey==='bomber' ? 70 : typeKey==='archer' ? 45 : 40;
        }
        update() {
            const dM = Math.hypot(this.x-master.x, this.y-master.y);
            if (dM > 175) { const a = Math.atan2(master.y-this.y, master.x-this.x); this.x += Math.cos(a)*this.speed*2; this.y += Math.sin(a)*this.speed*2; return; }
            
            // íƒ€ê²Ÿì´ ì—†ê±°ë‚˜ ì£½ì—ˆìœ¼ë©´ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
            if (!this.target || this.target.hp <= 0) {
                let closestEnemy = null;
                let closestDist = Infinity;
                
                enemies.forEach(e => {
                    if (e.hp > 0) {
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        // ê¸°ì§€ ì£¼ë³€ 195 ë²”ìœ„ ë‚´ì˜ ì ë§Œ ê³ ë ¤
                        const distToMaster = Math.hypot(e.x - master.x, e.y - master.y);
                        if (distToMaster < 195 && dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = e;
                        }
                    }
                });
                
                this.target = closestEnemy;
            }
            
            if (this.target) {
                const d = Math.hypot(this.target.x-this.x, this.target.y-this.y);
                if (d <= this.range) { if (this.cooldown <= 0) { this.attack(); this.cooldown = this.maxCooldown; } }
                else { const a = Math.atan2(this.target.y-this.y, this.target.x-this.x); this.x += Math.cos(a)*this.speed; this.y += Math.sin(a)*this.speed; }
            }
            if (this.cooldown > 0) this.cooldown--;
            units.forEach(o => { if(o!==this) { const d = Math.hypot(this.x-o.x, this.y-o.y); if(d < this.radius+o.radius) { const a = Math.atan2(this.y-o.y, this.x-o.x); this.x += Math.cos(a)*0.5; this.y += Math.sin(a)*0.5; } } });
            if (dM < master.radius + this.radius) { const a = Math.atan2(this.y-master.y, this.x-master.x); this.x = master.x + Math.cos(a)*(master.radius+this.radius); this.y = master.y + Math.sin(a)*(master.radius+this.radius); }
        }
        attack() {
            if (this.type==='knight' || this.type==='golem') { this.target.takeDamage(this.damage); if(this.type==='golem') shake=3; spawnParticles(this.target.x, this.target.y, '#fff', 3); }
            else projectiles.push(new Projectile(this.x, this.y, this.target, this.type, this.damage));
        }
        takeDamage(d) { 
            this.hp -= d; 
            if(this.hp <= 0) {
                spawnParticles(this.x, this.y, this.color, 8);
            }
        }
        draw() { 
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); 
            ctx.fillStyle=this.color; ctx.fill(); 
            ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.stroke();
            // HP ë°” í‘œì‹œ
            if(this.hp < this.maxHp) {
                ctx.fillStyle='#000'; ctx.fillRect(this.x-this.radius, this.y-this.radius-8, this.radius*2, 3);
                ctx.fillStyle='#2ed573'; ctx.fillRect(this.x-this.radius, this.y-this.radius-8, (this.radius*2)*(this.hp/this.maxHp), 3);
            }
        }
    }

    class Projectile {
        constructor(x, y, target, type, damage) { Object.assign(this, { x, y, target, type, damage, active: true, speed: type==='bomber'?4:7 }); }
        update() {
            const a = Math.atan2(this.target.y-this.y, this.target.x-this.x); this.x += Math.cos(a)*this.speed; this.y += Math.sin(a)*this.speed;
            if (Math.hypot(this.x-this.target.x, this.y-this.target.y) < 10) {
                if(this.type==='bomber') { shake=6; enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < 45) e.takeDamage(this.damage); }); spawnParticles(this.x, this.y, '#e17055', 15); }
                else { this.target.takeDamage(this.damage); if(this.type==='mage') this.target.slow = 120; spawnParticles(this.x, this.y, '#fff', 3); }
                this.active = false;
            }
        }
        draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.type==='bomber'?6:4, 0, Math.PI*2); ctx.fillStyle=this.type==='bomber'?'#e17055':this.type==='mage'?'#a29bfe':'#fff'; ctx.fill(); }
    }

    class Enemy {
        constructor(isBoss = false) {
            const a = Math.random()*Math.PI*2; this.x = width/2+Math.cos(a)*350; this.y = height/2+Math.sin(a)*350;
            this.isBoss = isBoss; this.radius = isBoss ? 22 : 11;
            
            // ë‚œì´ë„ ê³„ì‚°: ì›¨ì´ë¸Œ + ë³´ìŠ¤ ì²˜ì¹˜ íšŸìˆ˜ì— ë”°ë¥¸ ì¦ê°€
            const difficultyMultiplier = 1 + bossesDefeated * 0.3; // ë³´ìŠ¤ ì²˜ì¹˜ë§ˆë‹¤ 30% ì¦ê°€
            const baseHp = (35 + wave * 8) * difficultyMultiplier;
            this.hp = baseHp * (isBoss ? 5 : 1); 
            this.maxHp = this.hp; 
            this.damage = (isBoss ? 40 : 15) * difficultyMultiplier; // ê³µê²©ë ¥ë„ ì¦ê°€
            this.slow = 0;
            this.target = null; // íƒ€ê²Ÿ (ê¸°ì§€ ë˜ëŠ” ìœ ë‹›)
            this.searchRange = 200; // íƒìƒ‰ ë²”ìœ„
            this.attackRange = this.radius + 15; // ê³µê²© ë²”ìœ„
            this.attackCooldown = 0;
        }
        update() {
            // íƒ€ê²Ÿ ì°¾ê¸°
            if (!this.target || (this.target.hp !== undefined && this.target.hp <= 0)) {
                this.findTarget();
            }
            
            // íƒ€ê²Ÿì´ ìˆìœ¼ë©´ íƒ€ê²Ÿìœ¼ë¡œ ì´ë™, ì—†ìœ¼ë©´ ê¸°ì§€ë¡œ ì´ë™
            let targetX, targetY;
            if (this.target) {
                if (this.target === master) {
                    targetX = master.x;
                    targetY = master.y;
                } else {
                    // ìœ ë‹› íƒ€ê²Ÿ
                    targetX = this.target.x;
                    targetY = this.target.y;
                }
            } else {
                targetX = master.x;
                targetY = master.y;
            }
            
            const dist = Math.hypot(targetX - this.x, targetY - this.y);
            
            // ê³µê²© ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ê³µê²©
            if (dist <= this.attackRange && this.attackCooldown <= 0) {
                if (this.target === master) {
                    master.hp -= this.damage;
                    this.hp = 0;
                    shake = 10;
                } else if (this.target && this.target.hp !== undefined) {
                    // ìœ ë‹› ê³µê²©
                    this.target.takeDamage(this.damage * 0.6); // ìœ ë‹› ê³µê²©ì€ 60% ë°ë¯¸ì§€
                    this.attackCooldown = 30; // ê³µê²© ì¿¨íƒ€ì„
                }
            } else if (dist > this.attackRange) {
                // íƒ€ê²Ÿìœ¼ë¡œ ì´ë™
                const a = Math.atan2(targetY - this.y, targetX - this.x);
                const s = (this.slow > 0 ? 0.2 : 0.6) + wave * 0.04;
                this.x += Math.cos(a) * s;
                this.y += Math.sin(a) * s;
            }
            
            if (this.slow > 0) this.slow--;
            if (this.attackCooldown > 0) this.attackCooldown--;
        }
        findTarget() {
            this.target = null;
            const distToMaster = Math.hypot(master.x - this.x, master.y - this.y);
            
            // íƒìƒ‰ ë²”ìœ„ ë‚´ì— ê¸°ì§€ê°€ ìˆìœ¼ë©´ ê¸°ì§€ë¥¼ ìš°ì„  íƒ€ê²Ÿ
            if (distToMaster <= this.searchRange) {
                this.target = master;
                return;
            }
            
            // íƒìƒ‰ ë²”ìœ„ ë‚´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì•„êµ° ìœ ë‹› ì°¾ê¸°
            let closestUnit = null;
            let closestDist = this.searchRange;
            
            units.forEach(unit => {
                if (unit.hp > 0) {
                    const dist = Math.hypot(unit.x - this.x, unit.y - this.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestUnit = unit;
                    }
                }
            });
            
            if (closestUnit) {
                this.target = closestUnit;
            }
        }
        takeDamage(d) { 
            this.hp -= d; 
            if(this.hp <= 0) { 
                score += this.isBoss ? 500 : 10; 
                gold += this.isBoss ? 100 : 10; 
                if(this.isBoss) {
                    bossesDefeated++;
                }
                updateUI(); 
            } 
        }
        draw() { 
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); 
            ctx.fillStyle=this.slow>0?'#74b9ff':this.isBoss?'#2f3542':'#ff4757'; ctx.fill(); 
            if(this.isBoss) { ctx.strokeStyle='#ff4757'; ctx.lineWidth=2; ctx.stroke(); }
            ctx.fillStyle='#000'; ctx.fillRect(this.x-10, this.y-this.radius-5, 20, 3);
            ctx.fillStyle='#ff4757'; ctx.fillRect(this.x-10, this.y-this.radius-5, 20*(this.hp/this.maxHp), 3);
        }
    }

    class Particle {
        constructor(x, y, color) { this.x=x; this.y=y; this.c=color; this.v={x:(Math.random()-0.5)*4, y:(Math.random()-0.5)*4}; this.l=1.0; }
        update() { this.x+=this.v.x; this.y+=this.v.y; this.l-=0.03; }
        draw() { ctx.globalAlpha=this.l; ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1.0; }
    }

    function spawnParticles(x, y, c, n) { for(let i=0; i<n; i++) particles.push(new Particle(x, y, c)); }

    function useSpell(spellKey, x, y) {
        if(spellKey === 'blizzard' && mana >= 8) {
            mana -= 8; shake = 5;
            enemies.forEach(e => {
                if(Math.hypot(e.x - x, e.y - y) < 150) {
                    e.slow = 300;
                }
            });
            spawnParticles(x, y, '#00bfff', 50);
        } else if(spellKey === 'meteor' && mana >= 10) {
            mana -= 10; shake = 15;
            enemies.forEach(e => {
                if(Math.hypot(e.x - x, e.y - y) < 100) {
                    e.takeDamage(100 + wave * 10);
                }
            });
            spawnParticles(x, y, '#e84118', 80);
        }
        updateUI();
    }

    function drawCard() {
        if(hand.length < 3 && deck.length > 0) {
            let startIndex = deckIndex;
            let card = null;
            
            // íŒ¨ì— ì—†ëŠ” ì¹´ë“œì´ê³ , ë§ˆì§€ë§‰ ì‚¬ìš©í•œ ì¹´ë“œê°€ ì•„ë‹Œ ì¹´ë“œë¥¼ ì°¾ê¸°
            while (true) {
                const currentCard = deck[deckIndex];
                const cardKey = `${currentCard.type}_${currentCard.key}`;
                
                // íŒ¨ì— ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
                const isInHand = hand.some(c => `${c.type}_${c.key}` === cardKey);
                // ë§ˆì§€ë§‰ ì‚¬ìš©í•œ ì¹´ë“œì¸ì§€ í™•ì¸
                const isLastUsed = lastUsedCard && `${lastUsedCard.type}_${lastUsedCard.key}` === cardKey;
                
                // ì í•©í•œ ì¹´ë“œë¥¼ ì°¾ì•˜ìœ¼ë©´
                if (!isInHand && !isLastUsed) {
                    card = currentCard;
                    deckIndex = (deckIndex + 1) % deck.length;
                    break;
                }
                
                deckIndex = (deckIndex + 1) % deck.length;
                
                // ë±ì„ í•œ ë°”í€´ ëŒì•˜ëŠ”ì§€ í™•ì¸
                if (deckIndex === startIndex) {
                    // í•œ ë°”í€´ ëŒì•˜ëŠ”ë° ì í•©í•œ ì¹´ë“œê°€ ì—†ìœ¼ë©´, ë§ˆì§€ë§‰ ì‚¬ìš©í•œ ì¹´ë“œ ì œì™¸ ì¡°ê±´ë§Œ ë¬´ì‹œí•˜ê³  ì°¾ê¸°
                    let foundWithoutLastUsed = false;
                    for (let i = 0; i < deck.length; i++) {
                        const checkCard = deck[(startIndex + i) % deck.length];
                        const checkKey = `${checkCard.type}_${checkCard.key}`;
                        const checkIsInHand = hand.some(c => `${c.type}_${c.key}` === checkKey);
                        if (!checkIsInHand) {
                            card = checkCard;
                            deckIndex = ((startIndex + i) % deck.length + 1) % deck.length;
                            foundWithoutLastUsed = true;
                            break;
                        }
                    }
                    // ê·¸ë˜ë„ ì—†ìœ¼ë©´ ê·¸ëƒ¥ ë½‘ê¸°
                    if (!foundWithoutLastUsed) {
                        card = currentCard;
                        deckIndex = (deckIndex + 1) % deck.length;
                    }
                    break;
                }
            }
            
            if (card) {
                // ì¹´ë“œ ê°ì²´ë¥¼ ë³µì‚¬í•´ì„œ ìƒˆë¡œìš´ ê°ì²´ ìƒì„±
                hand.push({type: card.type, key: card.key});
            }
        }
    }

    function useCard(cardIndex) {
        if(cardIndex >= hand.length) return;
        const card = hand[cardIndex];
        const cardCost = card.type === 'spell' ? SPELL_TYPES[card.key].cost : UNIT_TYPES[card.key].cost;
        
        if(mana < cardCost) return;
        
        if(card.type === 'spell') {
            selectedSpell = card;
            selectedCard = null;
            canvas.style.cursor = 'crosshair';
        } else if(card.type === 'unit') {
            selectedCard = card.key;
            selectedSpell = null;
            canvas.style.cursor = 'pointer';
        }
        updateUI();
    }

    function playCard(x, y) {
        if(selectedSpell) {
            const spell = SPELL_TYPES[selectedSpell.key];
            if(mana >= spell.cost) {
                useSpell(selectedSpell.key, x, y);
                const cardIndex = hand.findIndex(c => c.type === 'spell' && c.key === selectedSpell.key);
                if(cardIndex !== -1) {
                    // ì‚¬ìš©í•œ ì¹´ë“œë¥¼ ì €ì¥
                    lastUsedCard = {...hand[cardIndex]};
                    hand.splice(cardIndex, 1);
                    drawCard();
                }
                selectedSpell = null;
                canvas.style.cursor = 'default';
            }
        } else if(selectedCard) {
            const unit = UNIT_TYPES[selectedCard];
            if(mana >= unit.cost) {
                mana -= unit.cost;
                for(let i=0; i<unit.count; i++) {
                    units.push(new Unit(x+(Math.random()-0.5)*35, y+(Math.random()-0.5)*35, selectedCard));
                }
                const cardIndex = hand.findIndex(c => c.type === 'unit' && c.key === selectedCard);
                if(cardIndex !== -1) {
                    // ì‚¬ìš©í•œ ì¹´ë“œë¥¼ ì €ì¥
                    lastUsedCard = {...hand[cardIndex]};
                    hand.splice(cardIndex, 1);
                    drawCard();
                }
                selectedCard = null;
                canvas.style.cursor = 'default';
            }
        }
        updateUI();
    }

    function updateUI() {
        if(gameState === 'game') {
            document.getElementById('gold').innerText = gold;
            document.getElementById('mana-text').innerText = Math.floor(mana);
            document.getElementById('mana-max').innerText = maxMana;
            document.getElementById('mana-bar-fill').style.width = (mana/maxMana*100)+'%';
            renderHand();
        }
    }

    function renderHand() {
        const container = document.getElementById('card-list'); container.innerHTML = '';
        for(let i = 0; i < 3; i++) {
            const wrap = document.createElement('div'); wrap.className = 'card-wrapper';
            if(i < hand.length) {
                const card = hand[i];
                let cardData, cardName, cardCost, cardColor, cardIcon, isSpell = false;
                
                if(card.type === 'unit') {
                    cardData = UNIT_TYPES[card.key];
                    cardName = cardData.name;
                    cardCost = cardData.cost;
                    cardColor = cardData.color;
                    cardIcon = '';
                } else {
                    cardData = SPELL_TYPES[card.key];
                    cardName = cardData.name;
                    cardCost = cardData.cost;
                    cardColor = cardData.color;
                    cardIcon = cardData.icon;
                    isSpell = true;
                }
                
                const isActive = (selectedCard === card.key && card.type === 'unit') || (selectedSpell && selectedSpell.key === card.key && card.type === 'spell');
                const canUse = mana >= cardCost;
                
                wrap.innerHTML = `
                    <div class="card ${isSpell ? 'spell-card' : ''} ${isActive ? 'active' : ''} ${!canUse ? 'disabled' : ''}" onclick="useCard(${i})">
                        <div class="card-cost">${cardCost}</div>
                        <div class="card-icon" style="background:${cardColor};">
                            ${isSpell ? cardIcon : ''}
                        </div>
                        <div style="font-size:9px; font-weight:bold; margin-top:3px;">${cardName}</div>
                        ${!isSpell ? `<div class="card-lvl">Lv.${cardData.level}</div>` : ''}
                    </div>`;
            } else {
                wrap.innerHTML = `<div class="card" style="opacity:0.3; border-style:dashed;"></div>`;
            }
            container.appendChild(wrap);
        }
    }

    function renderDeckSelection() {
        const container = document.getElementById('deck-list');
        container.innerHTML = '';
        Object.keys(DECKS).forEach(deckKey => {
            const deckData = DECKS[deckKey];
            const item = document.createElement('div');
            item.className = 'deck-item';
            item.onclick = () => selectDeck(deckKey);
            
            let cardsHtml = '';
            deckData.cards.forEach(card => {
                const isSpell = card.type === 'spell';
                const cardData = isSpell ? SPELL_TYPES[card.key] : UNIT_TYPES[card.key];
                cardsHtml += `<div class="deck-card-preview ${card.type}" style="background:${cardData.color};">
                    ${isSpell ? cardData.icon : ''}
                    <div style="font-size:8px; margin-top:3px;">${cardData.name}</div>
                </div>`;
            });
            
            item.innerHTML = `
                <div class="deck-name">${deckData.name}</div>
                <div class="deck-cards">${cardsHtml}</div>
            `;
            container.appendChild(item);
        });
    }

    function selectDeck(deckKey) {
        currentDeck = [...DECKS[deckKey].cards];
        startGame();
    }

    function startGame() {
        if(currentDeck.length === 0) return;
        gameState = 'game';
        deck = [...currentDeck];
        deckIndex = 0;
        hand = [];
        selectedCard = null;
        selectedSpell = null;
        lastUsedCard = null;
        
        // ì´ˆê¸° íŒ¨ 3ì¥ ë½‘ê¸° (ì¤‘ë³µ ì—†ì´)
        for(let i = 0; i < 3; i++) {
            drawCard();
        }
        
        document.getElementById('deck-selection').style.display = 'none';
        resetGame();
    }

    function backToMenu() {
        gameState = 'menu';
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('deck-selection').style.display = 'flex';
        currentDeck = [];
        deck = [];
        hand = [];
        selectedCard = null;
        selectedSpell = null;
        lastUsedCard = null;
        renderDeckSelection();
    }

    canvas.addEventListener('mousedown', (e) => {
        if(gameState !== 'game') return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if(selectedSpell || selectedCard) {
            playCard(x, y);
        }
    });

    function resetGame() {
        gold=120; wave=1; mana=6; score=0; isGameOver=false; units=[]; enemies=[]; projectiles=[]; frame=0; maxMana=10;
        bossesDefeated=0; enemySpawnTimer=0; bossSpawnedThisWave=false;
        master = new Master(); document.getElementById('game-over').style.display='none'; 
        Object.keys(UNIT_TYPES).forEach(k => { UNIT_TYPES[k].level = 1; UNIT_TYPES[k].upgCost = k==='knight'?50:k==='golem'?90:k==='archer'?60:k==='bomber'?100:80; });
        updateUI();
    }

    function loop() {
        if(gameState === 'game' && !isGameOver) {
            ctx.fillStyle='#1e272e'; ctx.fillRect(0,0,width,height);
            if(shake > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake*=0.9; }
            master.draw(); 
            units.forEach((u,i) => { u.update(); u.draw(); if(u.hp<=0) units.splice(i,1); });
            enemies.forEach((e,i) => { e.update(); e.draw(); if(e.hp<=0) enemies.splice(i,1); });
            projectiles.forEach((p,i) => { p.update(); p.draw(); if(!p.active) projectiles.splice(i,1); });
            particles.forEach((p,i) => { p.update(); p.draw(); if(p.l<=0) particles.splice(i,1); });
            
            if(frame%50===0 && mana < maxMana) { mana = Math.min(maxMana, mana+0.8); updateUI(); }
            
            // ì  ìŠ¤í° ì‹œìŠ¤í…œ ê°œì„ 
            enemySpawnTimer++;
            const baseSpawnInterval = Math.max(60, 100 - bossesDefeated * 5); // ë³´ìŠ¤ ì²˜ì¹˜ë§ˆë‹¤ ìŠ¤í° ê°„ê²© ê°ì†Œ (ë” ë¹ ë¥´ê²Œ)
            const spawnCount = 1 + Math.floor(bossesDefeated / 2); // ë³´ìŠ¤ ì²˜ì¹˜ë§ˆë‹¤ ìŠ¤í° ìˆ˜ ì¦ê°€
            
            if(enemySpawnTimer >= baseSpawnInterval) {
                enemySpawnTimer = 0;
                
                // 5ì›¨ì´ë¸Œë§ˆë‹¤ ë³´ìŠ¤ ë“±ì¥ (í•œ ì›¨ì´ë¸Œì— í•˜ë‚˜ë§Œ)
                if(wave % 5 === 0 && wave > 0 && !bossSpawnedThisWave && enemies.filter(e => e.isBoss).length === 0) {
                    enemies.push(new Enemy(true)); // ë³´ìŠ¤ ë“±ì¥
                    bossSpawnedThisWave = true; // ì´ë²ˆ ì›¨ì´ë¸Œì— ë³´ìŠ¤ ìŠ¤í° í‘œì‹œ
                    document.getElementById('boss-alert').style.display = 'inline';
                    setTimeout(() => document.getElementById('boss-alert').style.display = 'none', 3000);
                } else {
                    // ì¼ë°˜ ì  ìŠ¤í° (ë³´ìŠ¤ ì²˜ì¹˜ íšŸìˆ˜ì— ë”°ë¼ ì—¬ëŸ¬ ë§ˆë¦¬)
                    for(let i = 0; i < spawnCount; i++) {
                        enemies.push(new Enemy());
                    }
                }
            }
            
            if(frame%1200===0) { 
                wave++; 
                bossSpawnedThisWave = false; // ìƒˆ ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ë³´ìŠ¤ ìŠ¤í° í”Œë˜ê·¸ ë¦¬ì…‹
                document.getElementById('wave-num').innerText = wave; 
                if(maxMana < 20) maxMana++; 
            }
            if(master.hp <= 0) { isGameOver=true; document.getElementById('game-over').style.display='flex'; document.getElementById('final-score').innerText=score; document.getElementById('final-wave').innerText=wave; }
            if(shake > 0) ctx.restore(); frame++;
        }
        requestAnimationFrame(loop);
    }

    width = container.clientWidth; height = container.clientHeight; canvas.width=width; canvas.height=height;
    renderDeckSelection();
    loop();
</script>
</body>
</html>